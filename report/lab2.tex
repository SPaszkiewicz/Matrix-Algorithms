\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,
            tmargin=2cm,
            bmargin=2cm,
            lmargin=2cm,
            rmargin=2cm,
            bindingoffset=0cm]{geometry}

\usepackage{lmodern}
\usepackage[T1]{polski}
\usepackage[utf8]{inputenc}
\usepackage{tocloft}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{float}
\usepackage{booktabs}
\usepackage{algpseudocode}

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\title {
        Algorytmy Macierzowe \\
        Sprawozdanie 2 \\
        Rekurencyjne mnożenie macierzy

}

\author{Przemek Węglik \\ Szymon Paszkiewicz}

\date{\today}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Rekurencyjne odwracanie macierzy}

\subsection{Opis algorytmu}
\qquad Algorytm dzieli macierz na 4 podmacierze, następnie wykonuje na każdej macierzy odpowiednie operacje:
\begin{equation}
A = 
     \begin{bmatrix}
      A_{1,1} & A_{1,2}  \\
      A_{2,1} & A_{2,2} \\
     \end{bmatrix}
\end{equation}
\begin{equation}
A_{1,1}^{-1} = inverse(A_{1,1})
\end{equation}
\begin{equation}
S^{-1} = inverse(A_{2,2} - A_{2,1} * A_{1,1}^{-1} * A_{1,2})
\end{equation}
\begin{equation}
A^{-1} =      
\begin{bmatrix}
      A_{1,1}^{-1}(I + A_{1,2}S^{-1} * A_{2,1} * A_{1,1}^{-1}) &
      -A_{1,1}^{-1} * A_{1,2} * S  \\
      -S * A_{2,1} * A_{1,1}^{-1} & S \\
    \end{bmatrix}
\end{equation}
gdzie:
\begin{itemize}
    \item[] A - macierz, którą chcemy odwrócić,
    \item[] inverse - funkcja rekurencyjna odwracająca macierz
    \item[] S - macierz pomocnicza
    
\end{itemize}

\subsection{Pseudo-kod}
\subsection{Benchmarki}
\subsection{Złożoność obliczeniowa}
Złożonośc obliczeniowa tego rozwiązania to $x^{3}$
\subsection{Porównanie rozwiązania}

\section{Rekurencyjna faktoryzacja LU}

\subsection{Opis algorytmu}

\begin{equation}
A = 
     \begin{pmatrix}
      A_{1,1} & A_{1,2}  \\
      A_{2,1} & A_{2,2} \\
     \end{pmatrix}
\end{equation}\\
\begin{equation}
[L_{1,1}, U_{1,1}] = LU(A_{1,1})
\end{equation}\\
\begin{equation}
[L_s, U_s]
= LU(A_{2,2} - A_{2,1}U_{1,1}^{-1}L_{1,1}^{-1}A_{1,2})
\end{equation}\\
\begin{equation}
L = 
    \begin{pmatrix}
        L_{1,1} & 0  \\         A_{2,1}U_{1,1}^{-1} & L_s \\
    \end{pmatrix}
\end{equation}\\
\begin{equation}
U = 
    \begin{pmatrix}
        U_{1,1} &  L_{1,1}^{-1}A_{1,2} \\         0 & U_s \\
    \end{pmatrix}
\end{equation}
\subsection{Pseudo-kod}
\subsection{Benchmarki}
\subsection{Złożoność obliczeniowa}
\subsection{Porównanie rozwiązania}

\section{Rekurencyjne obliczanie wyznacznika}

\subsection{Opis algorytmu}
\qquad Algorytm wykorzystuje faktoryzacja LU do obliczenia wyznacznika macierzy. Najpierw wykonujemy faktoryzacje, a następnie bierzemy wszystkie liczby z głównej przekątniej macierzy U i L, po czym mnożymi je wszystkie ze sobą. \\
\begin{equation}
[ L_{n,n}, U_{n,n} ] = LU(A_{n,n})
\end{equation}\\
\begin{equation}
U_{n,n} = 
 \begin{pmatrix}
  u_{1,1} & u_{1,2} & \cdots & u_{1,n} \\
  0 & u_{2,2} & \cdots & u_{2,n} \\
  \vdots  & \vdots  & \ddots & \vdots  \\
  0 & 0 & \cdots & u_{n,n} 
 \end{pmatrix}
\end{equation}\\
\begin{equation}
U_{n,n} = 
 \begin{pmatrix}
  u_{1,1} & u_{1,2} & \cdots & u_{1,n} \\
  0 & u_{2,2} & \cdots & u_{2,n} \\
  \vdots  & \vdots  & \ddots & \vdots  \\
  0 & 0 & \cdots & u_{n,n} 
 \end{pmatrix}
\end{equation}\\
\begin{equation}
det(A) = \prod_{i = 0}^{n} u_{i, i}
\end{equation}
\subsection{Pseudo-kod}
\subsection{Benchmarki}
\subsection{Złożoność obliczeniowa}
\qquad Złożoność obliczeniowa algorytmu zależy od funkcji wyznaczającej LU oraz od rozmiaru macierzy. Wiemy także, że złożoność obliczeniowa funkcji faktoryzującej jest zależna od rozmiaru macierzy i nie jest ona liniowa. Ostatecznie więc uzyskujemy: O() 
\subsection{Porównanie rozwiązania}
\end{document}
